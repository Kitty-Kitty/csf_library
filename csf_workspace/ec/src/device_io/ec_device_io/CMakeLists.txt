#set module name
SET(CSF_MODULE_PROJECT_NAME "ec_device_io")
SET(CSF_MODULE_LIBRARY_NAME ${CSF_MODULE_PROJECT_NAME})

SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ")
SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ")

SET(LIBRARY_OUTPUT_PATH ${CSF_PROJECT_OUTPUT_TOP_DIR}/${CSF_MODULE_PROJECT_NAME})

#grep "\"V" include/modules/connect/csf_ip_connect/csf_ip_connect_factory.hpp -m 1 | awk '{print $3}' | awk -F "\"" '{print $2}' | awk -F "V" '{print $2}'
EXECUTE_PROCESS(
    COMMAND grep "\"V" ${CMAKE_CURRENT_SOURCE_DIR}/ec_device_io.hpp -m 1
    COMMAND awk "{print $3}"
    COMMAND awk -F "\"" "{print $2}"
    COMMAND awk -F "V" "{print $2}"
    OUTPUT_VARIABLE CSF_MODULE_LIBRARY_VERSION
    OUTPUT_STRIP_TRAILING_WHITESPACE
)

IF( CSF_MODULE_LIBRARY_VERSION )
    SET(CSF_MODULE_LIBRARY_SHARED_NAME lib${CSF_MODULE_LIBRARY_NAME}-${CSF_MODULE_LIBRARY_VERSION}.so)
ELSE()
	MESSAGE(FATAL_ERROR "[ CSF_MODULE_LIBRARY_VERSION ] is null error!")
ENDIF()

#判断如果是x86平台，则不编译该模块
IF(CSF_PLATFORM STREQUAL "x86")
  MESSAGE(WARNING "project[ ${CSF_MODULE_PROJECT_NAME} ] unsupport platform[ ${CSF_PLATFORM} ]!")
  RETURN()
ENDIF()


#add src source
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR} CSF_SRC_FILES_LIST)

#get source in all sub directories
ALL_SOURCE_DIRECTORY_LIST(SUB_SRC_DIRECTORIES ${CMAKE_CURRENT_SOURCE_DIR})

FOREACH(SUB_SRC_DIRECTORY ${SUB_SRC_DIRECTORIES})
  ADD_SUBDIRECTORY(${SUB_SRC_DIRECTORY})
ENDFOREACH()

#添加boost宏，解决error: ‘current_exception’ is not a member of ‘std’问题
ADD_DEFINITIONS(-DBOOST_ASIO_DISABLE_STD_FUTURE -DSENSOR_TYPE=SONY_IMX323_CMOS_1080P_30FPS)

SET(CSF_MODULE_LINK_HISIV_LIBRARIES
		lib_hiae.a
		libisp.a
		libmpi.a
		libive.a
		libmd.a
		lib_hiae.a
		lib_hiawb.a
		lib_hiaf.a
		lib_hidefog.a
		lib_hiirauto.a
		libVoiceEngine.a
		libsns_imx323.a
	)

#add module library
IF(PC_PLATFORM STREQUAL "cpptestscan")

ADD_LIBRARY(${CSF_MODULE_LIBRARY_SHARED_NAME} STATIC
		${CSF_SRC_FILES_LIST}
		)

ELSE()

ADD_LIBRARY(${CSF_MODULE_LIBRARY_SHARED_NAME} SHARED 
		${CSF_SRC_FILES_LIST}
		)

ENDIF()


ADD_DEPENDENCIES(${CSF_MODULE_LIBRARY_SHARED_NAME}
	${CSF_PROJECT_LIBRARY_STATIC_NAME}
	${CSF_GLOBAL_PROJECT_LIBRARY_STATIC_NAME}
	)

TARGET_LINK_LIBRARIES(${CSF_MODULE_LIBRARY_SHARED_NAME}
    ${CSF_PROJECT_LIBRARY_STATIC_NAME}
	${CSF_GLOBAL_PROJECT_LIBRARY_STATIC_NAME}
	${BOOST_LIBRARIES}
	${CSF_MODULE_LINK_HISIV_LIBRARIES}
   )

# 按照一般的习惯，静态库名字跟动态库名字应该是一致的，只是扩展名不同；
SET_TARGET_PROPERTIES(${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES OUTPUT_NAME ${CSF_MODULE_PROJECT_NAME})


# cmake在构建一个新的target时，会尝试清理掉其他使用这个名字的库，
# 因此，在构建libhello.a时，就会清理掉libhello.so.
# 为了回避这个问题，比如再次使用SET_TARGET_PROPERTIES定义 CLEAN_DIRECT_OUTPUT属性。
SET_TARGET_PROPERTIES (${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1)


# 按照规则，动态库是应该包含一个版本号的，
# VERSION指代动态库版本，SOVERSION指代API版本。
STRING(SUBSTRING ${CSF_MODULE_LIBRARY_VERSION} 0 1 CSF_MODULE_LIBRARY_VERSION_MAJOR)
SET_TARGET_PROPERTIES (${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES VERSION ${CSF_MODULE_LIBRARY_VERSION} SOVERSION ${CSF_MODULE_LIBRARY_VERSION_MAJOR})


MESSAGE(STATUS " ")
MESSAGE(STATUS "--------------------------------------------------------------")
MESSAGE(STATUS "build [ module ] project[ ${CSF_MODULE_PROJECT_NAME} ]")
MESSAGE(STATUS "shared library:[ ${CSF_MODULE_LIBRARY_SHARED_NAME} ]")
MESSAGE(STATUS "build library:[ ${CSF_MODULE_PROJECT_NAME} ]")
MESSAGE(STATUS "--------------------------------------------------------------")
