
#设置模块的名称，如果代码中没有指定模块名时，将使用该模块名
SET(CSF_MODULE_PROJECT_NAME "csf_directory_monitor")
SET(CSF_MODULE_TARGET_NAME ${CSF_MODULE_PROJECT_NAME})

SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ")
SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ")

SET(LIBRARY_OUTPUT_PATH ${CSF_PROJECT_OUTPUT_TOP_DIR}/${CSF_MODULE_PROJECT_NAME})

#表示当前描述版本信息的代码文件
SET(CSF_MODULE_VERSION_FILE ${CMAKE_CURRENT_SOURCE_DIR}/csf_directory_monitor.hpp)

#grep "\"V" include/modules/connect/csf_ip_connect/csf_ip_connect_factory.hpp -m 1 | awk '{print $3}' | awk -F "\"" '{print $2}' | awk -F "V" '{print $2}'
#从代码中获取版本号信息
EXECUTE_PROCESS(
    COMMAND grep "\"V" ${CSF_MODULE_VERSION_FILE} -m 1
    COMMAND awk "{print $3}"
    COMMAND awk -F "\"" "{print $2}"
    COMMAND awk -F "V" "{print $2}"
    OUTPUT_VARIABLE CSF_MODULE_LIBRARY_VERSION
    OUTPUT_STRIP_TRAILING_WHITESPACE
)

#从代码中获取模块名称
EXECUTE_PROCESS(
    COMMAND grep "VAR" ${CSF_MODULE_VERSION_FILE} -m 1
    COMMAND awk "{print $3}"
	COMMAND awk -F "\"" "{print $2}"
    OUTPUT_VARIABLE CSF_MODULE_TARGET_NAME
    OUTPUT_STRIP_TRAILING_WHITESPACE
)

IF(NOT CSF_MODULE_TARGET_NAME )
    SET(CSF_MODULE_TARGET_NAME ${CSF_MODULE_PROJECT_NAME})
ENDIF()

IF( CSF_MODULE_LIBRARY_VERSION )
    SET(CSF_MODULE_LIBRARY_SHARED_NAME lib${CSF_MODULE_TARGET_NAME}-${CSF_MODULE_LIBRARY_VERSION}.so)
ELSE()
    SET(CSF_MODULE_LIBRARY_VERSION "1.0.0")
    MESSAGE(FATAL_ERROR "[ CSF_MODULE_LIBRARY_VERSION ] is null error!")
ENDIF()

#MESSAGE(STATUS "CSF_MODULE_LIBRARY_VERSION = [ ${CSF_MODULE_LIBRARY_VERSION} ]")
#MESSAGE(STATUS "CSF_MODULE_LIBRARY_SHARED_NAME = [ ${CSF_MODULE_LIBRARY_SHARED_NAME} ]")

#add src source
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR} CSF_SRC_FILES_LIST)

#get source in all sub directories
ALL_SOURCE_DIRECTORY_LIST(SUB_SRC_DIRECTORIES ${CMAKE_CURRENT_SOURCE_DIR})

FOREACH(SUB_SRC_DIRECTORY ${SUB_SRC_DIRECTORIES})
  ADD_SUBDIRECTORY(${SUB_SRC_DIRECTORY})
ENDFOREACH()

#添加boost宏，解决error: ‘current_exception’ is not a member of ‘std’问题
ADD_DEFINITIONS(-DBOOST_ASIO_DISABLE_STD_FUTURE -DBOOST_SYSTEM_ENABLE_DEPRECATED)

#add module library
IF(PC_PLATFORM STREQUAL "cpptestscan")

ADD_LIBRARY(${CSF_MODULE_LIBRARY_SHARED_NAME} STATIC
		${CSF_SRC_FILES_LIST}
		)

ELSE()

ADD_LIBRARY(${CSF_MODULE_LIBRARY_SHARED_NAME} SHARED 
		${CSF_SRC_FILES_LIST}
		)

ENDIF()

#添加目录监控所需要的dir_monitor-1.0.0地址
INCLUDE_DIRECTORIES(${CSF_PROJECT_SOURCE_DIR}/third-party/src/dir_monitor-1.0.0/include)

ADD_DEPENDENCIES(${CSF_MODULE_LIBRARY_SHARED_NAME}
	${CSF_PROJECT_LIBRARY_STATIC_NAME})

TARGET_LINK_LIBRARIES(${CSF_MODULE_LIBRARY_SHARED_NAME}
    ${CSF_PROJECT_LIBRARY_STATIC_NAME}
	${BOOST_LIBRARIES}
   )

# 按照一般的习惯，静态库名字跟动态库名字应该是一致的，只是扩展名不同；
SET_TARGET_PROPERTIES(${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES OUTPUT_NAME ${CSF_MODULE_TARGET_NAME})


# cmake在构建一个新的target时，会尝试清理掉其他使用这个名字的库，
# 因此，在构建libhello.a时，就会清理掉libhello.so.
# 为了回避这个问题，比如再次使用SET_TARGET_PROPERTIES定义 CLEAN_DIRECT_OUTPUT属性。
SET_TARGET_PROPERTIES (${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1)


# 按照规则，动态库是应该包含一个版本号的，
# VERSION指代动态库版本，SOVERSION指代API版本。
STRING(SUBSTRING ${CSF_MODULE_LIBRARY_VERSION} 0 1 CSF_MODULE_LIBRARY_VERSION_MAJOR)
SET_TARGET_PROPERTIES (${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES VERSION ${CSF_MODULE_LIBRARY_VERSION} SOVERSION ${CSF_MODULE_LIBRARY_VERSION_MAJOR})


MESSAGE(STATUS " ")
MESSAGE(STATUS "--------------------------------------------------------------")
MESSAGE(STATUS "build [ module ] project[ ${CSF_MODULE_TARGET_NAME} ]")
MESSAGE(STATUS "shared library:[ ${CSF_MODULE_LIBRARY_SHARED_NAME} ]")
MESSAGE(STATUS "build library:[ ${CSF_MODULE_TARGET_NAME} ]")
MESSAGE(STATUS "--------------------------------------------------------------")
