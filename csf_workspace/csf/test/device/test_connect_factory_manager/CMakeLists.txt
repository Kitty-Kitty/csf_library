
#set module name
SET(CSF_MODULE_PROJECT_NAME "test_connect_factory_manager")
SET(CSF_MODULE_LIBRARY_NAME ${CSF_MODULE_PROJECT_NAME})

SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ")
SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ")

SET(LIBRARY_OUTPUT_PATH ${CSF_PROJECT_OUTPUT_TOP_DIR}/${CSF_MODULE_PROJECT_NAME})

#grep "\"V" include/modules/connect/csf_ip_connect/csf_ip_connect_factory.hpp -m 1 | awk '{print $3}' | awk -F "\"" '{print $2}' | awk -F "V" '{print $2}'
EXECUTE_PROCESS(
    COMMAND grep "\"V" ${CMAKE_CURRENT_SOURCE_DIR}/test_connect_factory_manager.hpp -m 1
    COMMAND awk "{print $3}"
    COMMAND awk -F "\"" "{print $2}"
    COMMAND awk -F "V" "{print $2}"
    OUTPUT_VARIABLE CSF_MODULE_LIBRARY_VERSION
    OUTPUT_STRIP_TRAILING_WHITESPACE
)

IF( CSF_MODULE_LIBRARY_VERSION )
    SET(CSF_MODULE_LIBRARY_SHARED_NAME lib${CSF_MODULE_LIBRARY_NAME}-${CSF_MODULE_LIBRARY_VERSION}.so)
ELSE()
	MESSAGE(FATAL_ERROR "[ CSF_MODULE_LIBRARY_VERSION ] is null error!")
ENDIF()

#MESSAGE(STATUS "CSF_MODULE_LIBRARY_VERSION = [ ${CSF_MODULE_LIBRARY_VERSION} ]")
#MESSAGE(STATUS "CSF_MODULE_LIBRARY_SHARED_NAME = [ ${CSF_MODULE_LIBRARY_SHARED_NAME} ]")

#add src source
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR} CSF_SRC_FILES_LIST)

#添加boost宏，解决error: ‘current_exception’ is not a member of ‘std’问题
ADD_DEFINITIONS(-DBOOST_ASIO_DISABLE_STD_FUTURE)

#add module library
IF(PC_PLATFORM STREQUAL "cpptestscan")
	ADD_LIBRARY(${CSF_MODULE_LIBRARY_SHARED_NAME} STATIC ${CSF_SRC_FILES_LIST})
ELSE()
	ADD_LIBRARY(${CSF_MODULE_LIBRARY_SHARED_NAME} SHARED ${CSF_SRC_FILES_LIST})
ENDIF()


ADD_DEPENDENCIES(${CSF_MODULE_LIBRARY_SHARED_NAME}
	${CSF_PROJECT_LIBRARY_STATIC_NAME})

TARGET_LINK_LIBRARIES(${CSF_MODULE_LIBRARY_SHARED_NAME}
    ${CSF_PROJECT_LIBRARY_STATIC_NAME}
	${BOOST_LIBRARIES}
   )

# 按照一般的习惯，静态库名字跟动态库名字应该是一致的，只是扩展名不同；
SET_TARGET_PROPERTIES(${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES OUTPUT_NAME ${CSF_MODULE_PROJECT_NAME})


# cmake在构建一个新的target时，会尝试清理掉其他使用这个名字的库，
# 因此，在构建libhello.a时，就会清理掉libhello.so.
# 为了回避这个问题，比如再次使用SET_TARGET_PROPERTIES定义 CLEAN_DIRECT_OUTPUT属性。
SET_TARGET_PROPERTIES (${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1)


# 按照规则，动态库是应该包含一个版本号的，
# VERSION指代动态库版本，SOVERSION指代API版本。
STRING(SUBSTRING ${CSF_MODULE_LIBRARY_VERSION} 0 1 CSF_MODULE_LIBRARY_VERSION_MAJOR)
SET_TARGET_PROPERTIES (${CSF_MODULE_LIBRARY_SHARED_NAME} PROPERTIES VERSION ${CSF_MODULE_LIBRARY_VERSION} SOVERSION ${CSF_MODULE_LIBRARY_VERSION_MAJOR})


MESSAGE(STATUS " ")
MESSAGE(STATUS "--------------------------------------------------------------")
MESSAGE(STATUS "build [ module ] project[ ${CSF_MODULE_PROJECT_NAME} ]")
MESSAGE(STATUS "shared library:[ ${CSF_MODULE_LIBRARY_SHARED_NAME} ]")
MESSAGE(STATUS "build library:[ ${CSF_MODULE_PROJECT_NAME} ]")
MESSAGE(STATUS "--------------------------------------------------------------")
